// Generated by psc version 0.8.5.0
"use strict";
var Prelude = require("../Prelude");
var Data_Comparison = require("../Data.Comparison");
var Data_Either = require("../Data.Either");
var Data_Equivalence = require("../Data.Equivalence");
var Data_Functor_Contravariant = require("../Data.Functor.Contravariant");
var Data_Monoid = require("../Data.Monoid");
var Data_Op = require("../Data.Op");
var Data_Predicate = require("../Data.Predicate");
var Data_Tuple = require("../Data.Tuple");
var Divide = function (__superclass_Data$dotFunctor$dotContravariant$dotContravariant_0, divide) {
    this["__superclass_Data.Functor.Contravariant.Contravariant_0"] = __superclass_Data$dotFunctor$dotContravariant$dotContravariant_0;
    this.divide = divide;
};
var Divisible = function (__superclass_Data$dotFunctor$dotContravariant$dotDivisible$dotDivide_0, conquer) {
    this["__superclass_Data.Functor.Contravariant.Divisible.Divide_0"] = __superclass_Data$dotFunctor$dotContravariant$dotDivisible$dotDivide_0;
    this.conquer = conquer;
};
var Decide = function (__superclass_Data$dotFunctor$dotContravariant$dotDivisible$dotDivide_0, decide) {
    this["__superclass_Data.Functor.Contravariant.Divisible.Divide_0"] = __superclass_Data$dotFunctor$dotContravariant$dotDivisible$dotDivide_0;
    this.decide = decide;
};
var Decidable = function (__superclass_Data$dotFunctor$dotContravariant$dotDivisible$dotDecide_0, __superclass_Data$dotFunctor$dotContravariant$dotDivisible$dotDivisible_1, lose) {
    this["__superclass_Data.Functor.Contravariant.Divisible.Decide_0"] = __superclass_Data$dotFunctor$dotContravariant$dotDivisible$dotDecide_0;
    this["__superclass_Data.Functor.Contravariant.Divisible.Divisible_1"] = __superclass_Data$dotFunctor$dotContravariant$dotDivisible$dotDivisible_1;
    this.lose = lose;
};
var lose = function (dict) {
    return dict.lose;
};
var dividePredicate = new Divide(function () {
    return Data_Predicate.contravariantPredicate;
}, function (f) {
    return function (v) {
        return function (v1) {
            return function (a) {
                var $30 = f(a);
                return v($30.value0) && v1($30.value1);
            };
        };
    };
});
var divisiblePredicate = new Divisible(function () {
    return dividePredicate;
}, Prelude["const"](true));
var divideOp = function (dictSemigroup) {
    return new Divide(function () {
        return Data_Op.contravariantOp;
    }, function (f) {
        return function (v) {
            return function (v1) {
                return function (a) {
                    var $36 = f(a);
                    return Prelude["<>"](dictSemigroup)(v($36.value0))(v1($36.value1));
                };
            };
        };
    });
};
var divisibleOp = function (dictMonoid) {
    return new Divisible(function () {
        return divideOp(dictMonoid["__superclass_Prelude.Semigroup_0"]());
    }, Data_Op.Op(Prelude["const"](Data_Monoid.mempty(dictMonoid))));
};
var divideEquivalence = new Divide(function () {
    return Data_Equivalence.contravariantEquivalence;
}, function (f) {
    return function (v) {
        return function (v1) {
            return function (a) {
                return function (b) {
                    var $42 = f(a);
                    var $43 = f(b);
                    return v($42.value0)($43.value0) && v1($42.value1)($43.value1);
                };
            };
        };
    };
});
var divisibleEquivalence = new Divisible(function () {
    return divideEquivalence;
}, Data_Equivalence.Equivalence(function (v) {
    return function (v1) {
        return true;
    };
}));
var divideComparison = new Divide(function () {
    return Data_Comparison.contravariantComparison;
}, function (f) {
    return function (v) {
        return function (v1) {
            return function (a) {
                return function (b) {
                    var $53 = f(a);
                    var $54 = f(b);
                    return Prelude["<>"](Prelude.semigroupOrdering)(v($53.value0)($54.value0))(v1($53.value1)($54.value1));
                };
            };
        };
    };
});
var divisibleComparison = new Divisible(function () {
    return divideComparison;
}, Data_Comparison.Comparison(function (v) {
    return function (v1) {
        return Prelude.EQ.value;
    };
}));
var divide = function (dict) {
    return dict.divide;
};
var divided = function (dictDivide) {
    return divide(dictDivide)(Prelude.id(Prelude.categoryFn));
};
var decidePredicate = new Decide(function () {
    return dividePredicate;
}, function (f) {
    return function (v) {
        return function (v1) {
            return Data_Predicate.Predicate(function ($92) {
                return Data_Either.either(v)(v1)(f($92));
            });
        };
    };
});
var decideOp = function (dictSemigroup) {
    return new Decide(function () {
        return divideOp(dictSemigroup);
    }, function (f) {
        return function (v) {
            return function (v1) {
                return Data_Op.Op(function ($93) {
                    return Data_Either.either(v)(v1)(f($93));
                });
            };
        };
    });
};
var decideEquivalence = new Decide(function () {
    return divideEquivalence;
}, function (f) {
    return function (v) {
        return function (v1) {
            return function (a) {
                return function (b) {
                    var $70 = f(a);
                    if ($70 instanceof Data_Either.Left) {
                        var $71 = f(b);
                        if ($71 instanceof Data_Either.Left) {
                            return v($70.value0)($71.value0);
                        };
                        if ($71 instanceof Data_Either.Right) {
                            return false;
                        };
                        throw new Error("Failed pattern match at Data.Functor.Contravariant.Divisible line 110, column 15 - line 113, column 5: " + [ $71.constructor.name ]);
                    };
                    if ($70 instanceof Data_Either.Right) {
                        var $75 = f(b);
                        if ($75 instanceof Data_Either.Left) {
                            return false;
                        };
                        if ($75 instanceof Data_Either.Right) {
                            return v1($70.value0)($75.value0);
                        };
                        throw new Error("Failed pattern match at Data.Functor.Contravariant.Divisible line 113, column 16 - line 117, column 1: " + [ $75.constructor.name ]);
                    };
                    throw new Error("Failed pattern match at Data.Functor.Contravariant.Divisible line 109, column 66 - line 117, column 1: " + [ $70.constructor.name ]);
                };
            };
        };
    };
});
var decideComparison = new Decide(function () {
    return divideComparison;
}, function (f) {
    return function (v) {
        return function (v1) {
            return function (a) {
                return function (b) {
                    var $82 = f(a);
                    if ($82 instanceof Data_Either.Left) {
                        var $83 = f(b);
                        if ($83 instanceof Data_Either.Left) {
                            return v($82.value0)($83.value0);
                        };
                        if ($83 instanceof Data_Either.Right) {
                            return Prelude.LT.value;
                        };
                        throw new Error("Failed pattern match at Data.Functor.Contravariant.Divisible line 98, column 15 - line 101, column 5: " + [ $83.constructor.name ]);
                    };
                    if ($82 instanceof Data_Either.Right) {
                        var $87 = f(b);
                        if ($87 instanceof Data_Either.Left) {
                            return Prelude.GT.value;
                        };
                        if ($87 instanceof Data_Either.Right) {
                            return v1($82.value0)($87.value0);
                        };
                        throw new Error("Failed pattern match at Data.Functor.Contravariant.Divisible line 101, column 16 - line 105, column 1: " + [ $87.constructor.name ]);
                    };
                    throw new Error("Failed pattern match at Data.Functor.Contravariant.Divisible line 97, column 63 - line 105, column 1: " + [ $82.constructor.name ]);
                };
            };
        };
    };
});
var decide = function (dict) {
    return dict.decide;
};
var decided = function (dictDecide) {
    return decide(dictDecide)(Prelude.id(Prelude.categoryFn));
};
var decidablePredicate = new Decidable(function () {
    return decidePredicate;
}, function () {
    return divisiblePredicate;
}, Data_Predicate.Predicate);
var decidableOp = function (dictMonoid) {
    return new Decidable(function () {
        return decideOp(dictMonoid["__superclass_Prelude.Semigroup_0"]());
    }, function () {
        return divisibleOp(dictMonoid);
    }, Data_Op.Op);
};
var decidableEquivalence = new Decidable(function () {
    return decideEquivalence;
}, function () {
    return divisibleEquivalence;
}, Data_Equivalence.Equivalence);
var decidableComparison = new Decidable(function () {
    return decideComparison;
}, function () {
    return divisibleComparison;
}, function (f) {
    return function (a) {
        return function (v) {
            return f(a);
        };
    };
});
var conquer = function (dict) {
    return dict.conquer;
};
module.exports = {
    Decidable: Decidable, 
    Decide: Decide, 
    Divisible: Divisible, 
    Divide: Divide, 
    lose: lose, 
    decided: decided, 
    decide: decide, 
    conquer: conquer, 
    divided: divided, 
    divide: divide, 
    divideComparison: divideComparison, 
    divisibleComparison: divisibleComparison, 
    divideEquivalence: divideEquivalence, 
    divisibleEquivalence: divisibleEquivalence, 
    dividePredicate: dividePredicate, 
    divisiblePredicate: divisiblePredicate, 
    divideOp: divideOp, 
    divisibleOp: divisibleOp, 
    decideComparison: decideComparison, 
    decidableComparison: decidableComparison, 
    decideEquivalence: decideEquivalence, 
    decidableEquivalence: decidableEquivalence, 
    decidePredicate: decidePredicate, 
    decidablePredicate: decidablePredicate, 
    decideOp: decideOp, 
    decidableOp: decidableOp
};
