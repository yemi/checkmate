// Generated by psc version 0.8.5.0
"use strict";
var Prelude = require("../Prelude");
var Control_Alt = require("../Control.Alt");
var Control_Alternative = require("../Control.Alternative");
var Control_Plus = require("../Control.Plus");
var Data_Foldable = require("../Data.Foldable");
var Data_List_Lazy = require("../Data.List.Lazy");
var Data_Monoid = require("../Data.Monoid");
var Data_Traversable = require("../Data.Traversable");
var ZipList = function (x) {
    return x;
};
var showZipList = function (dictShow) {
    return new Prelude.Show(function (v) {
        return "(ZipList " + (Prelude.show(Data_List_Lazy.showList(dictShow))(v) + ")");
    });
};
var runZipList = function (v) {
    return v;
};
var semigroupZipList = new Prelude.Semigroup(function (z1) {
    return function (z2) {
        return Prelude["++"](Data_List_Lazy.semigroupList)(runZipList(z1))(runZipList(z2));
    };
});
var monoidZipList = new Data_Monoid.Monoid(function () {
    return semigroupZipList;
}, Data_Monoid.mempty(Data_List_Lazy.monoidList));
var functorZipList = new Prelude.Functor(function (f) {
    return function (v) {
        return Prelude.map(Data_List_Lazy.functorList)(f)(v);
    };
});
var foldableZipList = new Data_Foldable.Foldable(function (dictMonoid) {
    return function (f) {
        return function (v) {
            return Data_Foldable.foldMap(Data_List_Lazy.foldableList)(dictMonoid)(f)(v);
        };
    };
}, function (f) {
    return function (b) {
        return function (v) {
            return Data_Foldable.foldl(Data_List_Lazy.foldableList)(f)(b)(v);
        };
    };
}, function (f) {
    return function (b) {
        return function (v) {
            return Data_Foldable.foldr(Data_List_Lazy.foldableList)(f)(b)(v);
        };
    };
});
var traversableZipList = new Data_Traversable.Traversable(function () {
    return foldableZipList;
}, function () {
    return functorZipList;
}, function (dictApplicative) {
    return function (v) {
        return Prelude["<$>"]((dictApplicative["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(ZipList)(Data_Traversable.sequence(Data_List_Lazy.traversableList)(dictApplicative)(v));
    };
}, function (dictApplicative) {
    return function (f) {
        return function (v) {
            return Prelude["<$>"]((dictApplicative["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(ZipList)(Data_Traversable.traverse(Data_List_Lazy.traversableList)(dictApplicative)(f)(v));
        };
    };
});
var eqZipList = function (dictEq) {
    return new Prelude.Eq(function (z1) {
        return function (z2) {
            return Prelude.eq(Data_List_Lazy.eqList(dictEq))(runZipList(z1))(runZipList(z2));
        };
    });
};
var ordZipList = function (dictOrd) {
    return new Prelude.Ord(function () {
        return eqZipList(dictOrd["__superclass_Prelude.Eq_0"]());
    }, function (z1) {
        return function (z2) {
            return Prelude.compare(Data_List_Lazy.ordList(dictOrd))(runZipList(z1))(runZipList(z2));
        };
    });
};
var applyZipList = new Prelude.Apply(function () {
    return functorZipList;
}, function (v) {
    return function (v1) {
        return Data_List_Lazy.zipWith(Prelude["$"])(v)(v1);
    };
});
var applicativeZipList = new Prelude.Applicative(function () {
    return applyZipList;
}, function ($33) {
    return ZipList(Data_List_Lazy.repeat($33));
});
var altZipList = new Control_Alt.Alt(function () {
    return functorZipList;
}, Prelude.append(semigroupZipList));
var plusZipList = new Control_Plus.Plus(function () {
    return altZipList;
}, Data_Monoid.mempty(monoidZipList));
var alternativeZipList = new Control_Alternative.Alternative(function () {
    return plusZipList;
}, function () {
    return applicativeZipList;
});
module.exports = {
    ZipList: ZipList, 
    runZipList: runZipList, 
    showZipList: showZipList, 
    eqZipList: eqZipList, 
    ordZipList: ordZipList, 
    semigroupZipList: semigroupZipList, 
    monoidZipList: monoidZipList, 
    foldableZipList: foldableZipList, 
    traversableZipList: traversableZipList, 
    functorZipList: functorZipList, 
    applyZipList: applyZipList, 
    applicativeZipList: applicativeZipList, 
    altZipList: altZipList, 
    plusZipList: plusZipList, 
    alternativeZipList: alternativeZipList
};
